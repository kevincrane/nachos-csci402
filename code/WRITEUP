Title: Writeup for Project 3, Fall 2011

Date: 10/30/2011

Group Num 8:  Name      Email             Student ID
    Kevin Crane         kevincra@usc.edu  3218277159
    Michelle Forcier    mforcier@usc.edu  7557790576
    Ryan Ball           rball@usc.edu	    3005164367

I. Requirements

  Overall:  Support memory management and virtual memory, as well as
      implementing remote procedure calls.

  Part 1:   Implement software-management of the TLB with software-page
      translation, including software page translation for handling
      TLB misses.

  Part 2:   Implement virtual memory. Has to be able to move page data
      from memory to a swap file and back. Must be able to evict pages
      from memory to make room for new pages, using an IPT to keep
      track of pages between swap file and executable locations.

  Part 3:   Implement remote procedure calls for the locks and condition
      variable syscalls. Must be able to create, set values, and retrieve
      values. Commands sent from Nachos client to server, and must be
      able to handle multiple clients.


II. Assumptions: 


III. Design: 
- This section is to cover your logic and ideas as to how  you are going to 
  solve the problem presented.  This should include a description of classes, 
  algorithms, etc. 

  Parts 1 & 2 - 
  - Major parts modified:
    - AddrSpace
      - Constructor
      - RestoreState (Sets all values in TLB to invalid)
    - exception.cc
      - added new handler for PageFaultExceptions
      - incorporated the use of a TLB and IPT to allow for gradual loading of executable data
      - added a swapfile and page swapping to account for small allotment of memory
    - machine.h
      - NumPhysPages changed from 1024 pages to 32 pages. Forces swapping to happen as there are not enough pages to go around
    - IPTEntry.h
      - Created a container for IPT entries. Inherits from TranslationEntry but adds several important values (swapfile data, location of data, etc.)
    - system.h
      - Added locks and an OpenFile handler to work with the swapfile
  
	    
  AddrSpace Consructor
  - Saves a pointer to the executable file, no longer deletes executable as it needs to maintain a connection with it to keep reading data
  - Initialize all values in pageTable. Unlike in previous versions where all of the data from the executable is loaded in now, the 
    executable data is not read yet.
    
  PageFault Handler
  - handlePageFaul(int vAddress)
    - Disable interrupts
    - Increase the timestamp on all pages in the TLB
    - Find the correct IPT page matching the page that threw the PageFaultException
      - If it can't find a matching IPT page, search for a new one (handleIPTMiss)
    - Propagate dirty bits in the TLB to the IPT and thread pageTable
    - Copy all relevant fields from the IPT to the TLB
    - Restore Interrupts
  - handleIPTMiss(int vpn)
    - Search for a new free page from the page map
    - If it can't find one, time to evict a page (evictAPage)
    - Locate the data that needs to get stored in the new page
      - If it's in the swap file, locate it using its swapByteOffset, read it, and store it in the pageTable
      - If it's in the executable, read it and store it in the pageTable
  - evictAPage()
    - If FIFO eviction:
      - Find the page in the IPT with the largest timestamp and take that as the PPN to evict
    - If Random eviction:
      - Generate a random number and evict a page with that number
    - Propagate dirty bit from TLB to IPT and disable current page in TLB
    - Copy page from memory to swap page
    - Update PageTable to reflect page moving from memory to swapfile
	

  Part 3 - 
    Created a new file in the network directory called server.cc to
    act as both the server stub and the server application. 

    Server application runs a while loop that waits for a message,
    then figures out the syscall the message wants, then calls a 
    function to do work and return a value.

    Functions validate the input, then do any necessary work,
    then prepare a response message to send to the client.

    Example Function:

    void CreateLock(char* msg) {

      lockData myLock;
      char* response = new char[MAX_SIZE];
      char* name = new char[MAX_SIZE - 3];

      for(int i = 3; i < MAX_SIZE + 1; i++) {
        // Copy name part of the msg into name
      }

      for(int i = 0; i < nextLock; i++) {
        // Check if the lock already exists
        if(*lcks[i].lock.name == *name) {
          // Send a response with the existing
          // lock index
          return;
        }
      } 

      myLock.isDeleted = false;
      myLock.toBeDeleted = false;
      myLock.numActiveThreads = 0;
      myLock.lock.name = new char[MAX_SIZE];

      // Copy name into the myLock's name field

      if(nextLock >= MAX_LOCKS) {
        // Send an error response    				
      }
      else {
        // Add the lock to the array of locks
        // Send a successful response
      }

      outMailHeader.length = strlen(response) + 1;

      postOffice->Send(outPacketHeader, outMailHeader, response);

      nextLock++;
    }
    

IV. Implementation: 

    + Files Modified 

      WRITEUP

      Userprog Folder:  exception.cc
                        syscall.h
                        addrspace.cc
                        addrspace.h

      Threads Folder:   main.cc

      Test Folder:      testfiles.c
                        networktests.c
                        start.s

    + Files added 

      VM Folder:        iptEntry.h
      
      Network Folder:   server.cc

      Test Folder:      networktests.c
                        two_matmults.c (actually runs 7 matmults, as a demonstration of multiple processes)

    + Data Structures added, and the file they were added to. 

      iptEntry (extension of TranslationEntry) -- iptEntry.h
      
      PacketHeader inPacketHeader;		-- server.cc
      PacketHeader outPacketHeader;		-- server.cc
      MailHeader   inMailHeader;		-- server.cc
      MailHeader   outMailHeader;		-- server.cc

      char* message;				-- server.cc
      int nextLock;				-- server.cc
      int nextCV;				-- server.cc
      int nextMVPos;				-- server.cc

      class serverLock {			-- server.cc

		      char* name;
		      bool available;
		      int machineID;
		      int mailboxNum;
		      List* waitList;
      }

      class serverCV {			-- server.cc

	      char* name;
		      int lockIndex;
		      int machineID;
		      int mailboxNum;
		      List* waitList;

	      }

      class waitingThread {			-- server.cc

		      int machineID;
		      int mailboxNum;

      };

      struct lockData {			-- server.cc
		      serverLock lock;
		      bool isDeleted;
		      bool toBeDeleted;
		      int numActiveThreads;
      };

      struct cvData {				-- server.cc
		      serverCV condition;
		      bool isDeleted;
		      bool toBeDeleted;
		      int numActiveThreads;
      };

      struct mvData {				-- server.cc
		      int values[1000];
		      int size;
		      bool isDeleted;
		      char* name;
      };

      lockData lcks[MAX_LOCKS];		-- server.cc
      cvData   cvs[MAX_CVS];			-- server.cc
      mvData   mvs[MAX_MVS];			-- server.cc
      
      
    + Data Structures modified, and the file they were added to. 
      iptEntry pageTable;       -- addrSpace.h
      
      
    + Functions added and in which file. 
    
      int evictAPage();             -- exception.cc
      int handleIPTMiss(int vpn);   -- exception.cc
      void handlePageFault(int vAddress);   -- exception.cc

      void CreateLock(char* msg); 		-- server.cc
      void Acquire(int index);		-- server.cc
      void Release(int index);		-- server.cc
      void DestroyLock(int index);		-- server.cc
      void CreateCV(char* msg);		-- server.cc
      void Wait(char* msg);			-- server.cc
      void Signal(char* msg);			-- server.cc
      void Broadcast(char* msg);		-- server.cc
      void DestroyCV(char* msg);		-- server.cc
      void CreateMV(char* msg);		-- server.cc
      void Set(int index, int value, int arrayIndex); -- server.cc
      void Get(int index, int arrayIndex);	-- server.cc
      void DestroyMV(int index);		-- server.cc
      void Server();				-- server.cc


    + Functions modified and in which file. 

      void Acquire_Syscall(int lockIndex);	-- exception.cc
      void Release_Syscall(int lockIndex);	-- exception.cc
      void Wait_Syscall(int cvIndex, int lockIndex); -- exception.cc
      void Signal_Syscall(int cvIndex, int lockIndex); -- exception.cc
      void Broadcast_Syscall(int cvIndex, int lockIndex); -- exception.cc
      int  CreateLock_Syscall(unsigned int strPtr, int length); -- exception.cc
      void DestroyLock_Syscall(int lockIndex);-- exception.cc
      int  CreateCondition_Syscall(unsigned int strPtr, int length); -- exception.cc
      void DestroyCondition_Syscall(int cvIndex); -- exception.cc
      int  CreateMV_Syscall(unisgned int strPtr, int length, int arraySize); -- exception.cc
      void DestroyMV_Syscall(int index); 	-- exception.cc
      void SetMV_Syscall(int index, int value, int arrayIndex); -- exception.cc
      int  GetMV_Syscall(int index, int arrayIndex);	-- exception.cc
      void ExceptionHandler(ExceptionType which);	-- exception.cc
		
		
V. Testing:  (For each test case, you must show)
    + How to test
    
      (From network folder; must be compiled from here because of new 'network' features)
        gmake
      
    
      - FIFO vs. Random Eviction type
        - From network folder:
          nachos -P RAND -x ../test/{test_file}
          OR
          nachos -P FIFO -x ../test/{test_file}
      - Simple test of memory management/virtual memory
        - From network folder:
          nachos -P {RAND || FIFO} -x ../test/sort
          nachos -P {RAND || FIFO} -x ../test/matmult
      - Demonstration of multiple simultaneous processes using same memory/swapfile
          nachos -P {RAND || FIFO} -x ../test/two_matmults    [ (actually more 7 different matmults, just large-scale demo) ]
      
      - Demonstration of network functionality
        [NETWORK]
	

    + Test Output
    
      SORT EXPECTED OUTPUT
        Sort output=1023
        Exit: Nachos successfully shutting down.
        Machine halting!
      
      MATMULT EXPECTED OUTPUT
        Matmult output=7220
        Exit: Nachos successfully shutting down.
        Machine halting!
        
      TWO_MATMULTS EXPECTED OUTPUT
        Matmult 1!
        Matmult 2!
        Matmult 3!
        Matmult 4!
        Matmult 5!
        Matmult 6!
        Matmult 7!
        Matmult output=7220
        Matmult output=7220
        Matmult output=7220
        Matmult output=7220
        Matmult output=7220
        Matmult output=7220
        Matmult output=7220
        Exit: Nachos successfully shutting down.
        Machine halting!

		[NETWORK]
		

VI. Discussion: 
    + Experiment expectation.  (What you hope will happen.) 

      By the end of this project, we hope to have learned how to properly
      manage memory between multiple processes and a swapfile. This will
      involve some tricky interactions between the various processes, IPT
      and TLB, and the physical swapfile.
      In addition, we hope to learn about how to communicate between different
      Nachos instances through networking and a client-server interaction.

    + Experiment result.  (What actually happens.) 

      In the end, implementing the software memory management features were
      tough, but very doable. We created a very robust system of memory
      management that seems very capable for handling multiple threads and
      processes with ease.
      [NETWORK]

    + Explanation 

      I found that breaking the memory management portion into discrete steps
      (as Professor Crowley did in class) made it substantially easier to
      grasp and understand as we progressed, helping me to better understand
      the concepts as I went. 
      [NETWORK]
		  
VII. Miscellaneous: 

		



I love you.

